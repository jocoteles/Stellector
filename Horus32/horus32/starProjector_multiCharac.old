/*
    Star Projector ESP32 interface
    João Teles, jocoteles@gmail.com
    june/2020

    Some conventions:
    ------------------------------------------
    stepper = alias for step motor
    variables ended by capital letter 'C': it's a characteristic UUID
    step: is a stepper step value. It can vary only by -1, 0, or +1.
    segment: is a stepper step range, which is linearly followed by the stepper.
    path: the full array(s) of segments of a given steppers path execution.
*/

#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>

#define PATH_MAX_SIZE 3000      //maximum size of the steppers segments array
#define PATHBASE_SIZE 4         //size of the data chunk decodification
#define COMMBASE_SIZE 4         //size of the data chunk codification
#define DELAY_FACTOR 100        //factor to be multiplied to the delay path array in order to give the desired microseconds step delay

#define FSCYCLE 4               //steppers full step cycle
#define STPS360 2048            //steppers number of steps for a 360º rotation

//BLE variables:
//--------------
#define mainS_UUID          "e80fd323-0ae1-454f-bbd5-31b571083af5"  //The single service for all device's characteristics
#define modC_UUID           "050932d4-b627-48ca-a52c-1e37905a47e4"  //characteristic for choosing the starProjector operations mode
#define pathC_UUID          "20e75b2b-6be1-4b18-b1d0-a06018dbdab5"  //characteristic for the path array
#define posMeasureC_UUID    "e16843eb-fe97-42b4-acc7-83069473c1b5"  //characteristic for measuring the steppers position
#define confC_UUID          "8c1e0405-b586-4fd7-b6f4-25e9e3761a77"  //characteristic for confirming the path array size sent
// UUIDs generated at: https://www.uuidgenerator.net/

#define mainSnumHandles  10 // = 2*(n+1), where n is the maximum number of characteristics for the mainS service (default n = 7)

BLEServer *server;
BLEService *mainS;
BLECharacteristic *modC, *pathC, *posMeasureC, *confC;
BLEAdvertising *advertising = BLEDevice::getAdvertising();

uint16_t operationMode[3] = {0, 0, 4};  //position [0]: "execution mode" option (0: standby, 1: free movement, 2: exec path, 3: reset path), [1]: "fit init point" option, and [2]: "cyclic execution" option

//Steppers variables:
//-------------------
const int fullStep[FSCYCLE][4] = {  {0, 0, 1, 1},   //Phases of each stepper step
                                    {0, 1, 1, 0},
                                    {1, 1, 0, 0},
                                    {1, 0, 0, 1}};

const int stpr1[4] = {13, 12, 14, 27};   //mobile stepper GPIO pins (theta)
const int stpr2[4] = {23, 22, 32, 33};   //fixed stepper GPIO pins  (phi)
const int lPin = 35;                     //laser GPIO pin

uint16_t actStep[2] = {0, 0};   //actual step values for the fixed (phi) and mobile (theta) stepper, respectively

//Path variables:
//------------------
uint16_t phiP[PATH_MAX_SIZE];       //fixed stepper array of segments in step units
uint16_t thetaP[PATH_MAX_SIZE];     //mobile stepper array of segments in step units
uint16_t laserP[PATH_MAX_SIZE];     //laser state on/off array of segments (boolean - 1 bit)
uint16_t delayP[PATH_MAX_SIZE];     //step delay array of segments in 1 us times DELAY_FACTOR units
uint16_t pathSize = 0;
const uint8_t pathBase[PATHBASE_SIZE] = {1, 9, 11, 11};   //number of bits of the base used to represent the path segments, respectively for: laser state, step delay, phi step, theta step
const uint8_t commBase[COMMBASE_SIZE] = {8, 8, 8, 8};     //number of bits of the base used to communicate the path segments

/* variables declaration for data exchange as bytes:
    std::string myString(pointerToData, lengthOfData);
    std::string myStringForUnit16((char*)&myUint16, 2);
    pCharacteristic->setValue(myStringForUnit16);
*/

/*uint16_t stepF = 0;
uint16_t stepM, laserL;
uint16_t varControls = 0;
std::string readings;*/

uint16_t * decode(uint32_t x) {
  //x decodification in the "pathBase" array
  uint8_t b0 = 0;
  uint32_t r0 = x;
  unsigned long p1, p2;
  static uint16_t r[PATHBASE_SIZE];
  for (uint8_t i = 0; i < PATHBASE_SIZE; i++)
  {
    p1 = pow(2, b0);
    p2 = pow(2, pathBase[i]);
    r[i] = (r0 / p1) % p2;
    b0 += pathBase[i];
    r0 -= r[i];
  }
  return r;
}

uint16_t * readChunk(uint16_t a[], uint16_t r[]) {
  //Read a COMMBASE_SIZE size of the path array
  //Return the decoded representation in the "pathBase"
  uint32_t v = 0;
  uint8_t b = 0;
  unsigned long p;
  uint8_t b0 = 0;
  uint8_t i;
  unsigned long p1, p2;  
  for (i = 0; i < COMMBASE_SIZE; i++) {
    p = pow(2, b);
    v += a[i]*p;
    b += commBase[i];
  }
  for (i = 0; i < PATHBASE_SIZE; i++)
  {
    p1 = pow(2, b0);
    p2 = pow(2, pathBase[i]);
    r[i] = (v / p1) % p2;
    b0 += pathBase[i];
    v -= r[i];
  }
  //return r;
}

class MyCallbacks: public BLECharacteristicCallbacks {
    void onWrite(BLECharacteristic *pCharacteristic) {
      std::string value = pCharacteristic->getValue();
      uint16_t val;

      if (value.length() > 0) {
        Serial.println("*********");
        Serial.println("New value: ");
        for (int i = 0; i < value.length(); i++) {
          val = value[i];
          Serial.println(val);
        }        
        Serial.println("*********");
      }
    }
};

class ModeOperationCallback: public BLECharacteristicCallbacks {
    void onWrite(BLECharacteristic *pCharacteristic) {
      std::string values = pCharacteristic->getValue();      
      if (values.length() == 3) {
        for (int i = 0; i < values.length(); i++) operationMode[i] = values[i];          
        if (operationMode[0] == 3) pathSize = 0;
        //Serial.print("Op mode [0]: ");
        //Serial.println(operationMode[0]);
      }
    }
};

class ReadPathCallback: public BLECharacteristicCallbacks {
  void onWrite(BLECharacteristic *pCharacteristic) {
    std::string vals = pCharacteristic->getValue();
    uint16_t valsComm[COMMBASE_SIZE];
    uint16_t i;
    uint8_t j;      
    if (vals.length() > 0) {
      uint16_t r0[PATHBASE_SIZE];      
      for (i = 0; i < (vals.length() / COMMBASE_SIZE); i++)
      {
        for (j = 0; j < COMMBASE_SIZE; j++) valsComm[j] = vals[COMMBASE_SIZE*i + j];
        readChunk(valsComm, r0);
        laserP[pathSize+i] = r0[0];
        delayP[pathSize+i] = r0[1];
        phiP[pathSize+i] = r0[2];
        thetaP[pathSize+i] = r0[3];
      }
      pathSize += i;
      //confC->setValue(pathSize);
      //Serial.print("Path size: ");
      //Serial.println(pathSize);
    }
  }
};

void stepper (const int stpr[], uint16_t s) {
  for (int j = 0; j < 4; j++)
    digitalWrite(stpr[j], fullStep[s % FSCYCLE][j]);
}

void laser (bool s) {digitalWrite(lPin, s);}

void execPath() {
  uint16_t N, ph, th, phA, thA;
  int dph, dth;
  float fph, fth;
  unsigned long t0;

  phA = actStep[0];
  thA = actStep[1];  
  laser(0);  
  for (uint16_t j = 0; j < pathSize; j++)
  {
    ph = phiP[j];
    th = thetaP[j];    
    dph = ph - phA;
    dth = th - thA;    
    N = max(abs(dph), abs(dth));
    fph = float(dph)/N;
    fth = float(dth)/N;
    Serial.println(ph, th);
    for (uint16_t i = 0; i < N; i++)
    {
      ph = phA + int(i*fph);
      th = thA + int(i*fth);      
      stepper(stpr1, ph);
      stepper(stpr2, th);
      delayMicroseconds(delayP[j]*DELAY_FACTOR);
    }
    laser(laserP[j]);      
    phA = ph;
    thA = th;
  }
  actStep[0] = phA;
  actStep[1] = thA;
}

bool readPath() {
  while (operationMode[0] == 3) {}
}

void setup() {
  Serial.begin(115200);

  for (int i = 0; i < 4; i++) {
    pinMode(stpr1[i], OUTPUT);
    pinMode(stpr2[i], OUTPUT);
  }
  pinMode(lPin, OUTPUT);

  Serial.println("Starting BLE work!");

  BLEDevice::init("StarProjector");
  
  server = BLEDevice::createServer();
  mainS = server->createService(BLEUUID(mainS_UUID), mainSnumHandles);  // In order to set numHandles parameter, mainS_UUID must be converted by function BLEUUID
  modC = mainS->createCharacteristic(modC_UUID, BLECharacteristic::PROPERTY_WRITE);
  pathC = mainS->createCharacteristic(pathC_UUID, BLECharacteristic::PROPERTY_WRITE);
  posMeasureC = mainS->createCharacteristic(posMeasureC_UUID, BLECharacteristic::PROPERTY_READ);
  confC = mainS->createCharacteristic(confC_UUID, BLECharacteristic::PROPERTY_READ);
  
  //setControlsC->setCallbacks(new setControlsCallbacks());
  modC->setCallbacks(new ModeOperationCallback());
  pathC->setCallbacks(new ReadPathCallback());
  
  mainS->start();
  
  advertising->addServiceUUID(mainS_UUID);
  advertising->setScanResponse(true);
  advertising->setMinPreferred(0x06);  // functions that help with iPhone connections issue
  advertising->setMinPreferred(0x12);  
  BLEDevice::startAdvertising();  
}


void loop() {
  if (operationMode[0] == 1) { //Steppers free movement
    execPath();
    //accelReadings();
  }

  if (operationMode[0] == 2) { //Path execution
    do {
      //pathSize = 0;
      //readPath();
      //execPath();
      Serial.println(pathSize);
      delay(100);
    } while (operationMode[2] == 1);
  }
  delay(100);
  /*setControls = setControlsC->getValue();
  if (setControls.length() > 1) {
    //varControls = 0;
    for (int i = 0; i < setControls.length(); i++) {
      varControls += 1;//setControls[i];
    }
    getControlsC->setValue(varControls);
  }*/
  /*if (setControls.length() == 3 && stepF != setControls[0])
  {
    stepF = setControls[0];
    stepM = setControls[1];
    laserL = setControls[2];
    //varControls += stepF*64 + stepM*8 + laserL;
    //varControls = 2*stepF;
    varControls += 1;
    getControlsC->setValue(varControls);
    //Serial.println(stepF);
  }*/
  /*readings = thC->getValue();
  if (readings.length() > 1)
    for (int i = 0; i < readings.length(); i++) {
      stepF = readings[i];
      Serial.println(stepF);
    }
    readings = ""; */
  /*readings = thC->getValue();
  if (readings.length() > 0)
    for (int i = 0; i < readings.length(); i++) {
      stepF = readings[i];
      Serial.println(stepF);
    }
    readings = "";*/
  //delay(10000);
  //if (varControls >= 50) getControlsC->setValue(varControls);
}
