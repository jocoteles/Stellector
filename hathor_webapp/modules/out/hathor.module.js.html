<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: hathor.module.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: hathor.module.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * JS Module for the Hathor Web App.
 * @module
 */

import '../libs/three.min.js';
import { nelderMead } from '../libs/nelderMead.js';

/**
 * @param {object} ESP32 - constants used in the ESP32 server
 */
let ESP32 = {
	STPS360: 2038,				//steppers number of steps for a 360ยบ rotation
	STEP_AT_ZENITH: 1019,		//steppers step values corresponding to the Zenith direction
	HORIZON_MIN_ANG: 3.0,	    //laser minimum angle from horizon for safety operation [degrees]
	PATHBASE: [1, 9, 11, 11],	//number of bits of the base used to represent the path segments, respectively for: laser state, step delay, phi step, theta step
	COMMBASE: [8, 8, 8, 8],		//number of bits of the base used to communicate the path segments
	RESET_PATH_OPT: 1,       	//option to start a new path reading
	EXEC_PATH_OPT: 2,        	//option to execute the path
	CYCLIC_PATH_OPT: 3,     	//option to execute the path cyclicaly
	REVERSE_PATH_OPT: 4,	    //option to execute the path cyclicaly in reverse order alternately	
	LASER_SWITCH_OPT: 5,       	//option to turn on the laser	
	SET_ZENITH_OPT: 6,       	//option to make actSteps equal to STEP_AT_ZENITH
	READ_ACT_STEPS_OPT: 7,		//option to read the steppers actual steps	
	MAIN_S_UUID:          "643790f9-355d-435b-b407-43ebf47a86b4",  //The single service for all device's characteristics
	PATH_C_UUID:          "f467e4e9-e2bc-422f-b8a3-aaaf6f92b999",  //characteristic for the path array
	COMMAND_C_UUID:       "f7b0afdf-b51e-4ba7-9513-48fb15497f22",  //characteristic for command execution on server
	STEPPERS_C_UUID:  	  "6f23d28a-a3cb-4c5f-9d08-63fda0806966",  //characteristic for measuring the steppers position
	STATUS_C_UUID:        "4af8de6b-1f13-4dfb-b08e-0a4a97a983d5",  //characteristic for indicating the hardware status	
	DEVICE_NAME: "Stellector"
};



/**
 * A namespace for the coordinates operations.
 * @namespace
 */
let Coord = {};

/**
 * Class representing a unity vector in spherical coordinates (phi = 0 to 2*pi; theta = 0 to pi).
 */
Coord.Spherical = class {
    /**
     * Creates a spherical representation of a unity vector.
     * @param {number} phi - azimuthal angle: 0 to 2*pi.
	 * @param {number} theta - polar angle: 0 to pi.
     */
    constructor (phi = 0.0, theta = 0.0) {
		this._phi = phi;
		this._theta = theta;
		this.correctCoords();
	}
	/** Set this.phi */
	set phi (phi) {
		this._phi = phi;
		this.correctCoords();
	}
	/** Set this.theta */
	set theta (theta) {		
		this._theta = theta;
		this.correctCoords();
	}
	/** Get this.phi */
	get phi () {		
		return this._phi;
	}
	/** Get this.theta */
	get theta () {		
		return this._theta;
	}	
	/**
	 * Corrects coordinates to their boundary values.
	 */
	correctCoords () {
		let pi = Math.PI;
		let pi2 = 2.0*pi;
		let n = Math.ceil(Math.abs(this.phi)/pi2);
		this._phi = (n*pi2 + this._phi) % pi2;
		let m = Math.ceil(Math.abs(this.theta)/pi2);
		this._theta = (m*pi2 + this._theta) % pi2;
		if (this._theta > pi) {
			this._theta = pi2 - this._theta;
			this._phi = (this._phi + pi) % pi2;
		}
	}	
	/**
	 * Returns the rectangular representation of this object.
	 * @returns {THREE.Vector3} rectangular representation of this object.
	 */
	toVector3 () {		
		return new THREE.Vector3().setFromSphericalCoords(1.0, this._theta, this._phi);
		//Phi and theta are exchanged in Three.js in relation to the usual notation
	}	
	/**
	 * Set this object from rectangular representation.	 
	 * @param {THREE.Vector3} vec - rectangular representation of a vector.
	 */
	fromVector3 (vec) {
		let sph = new THREE.Spherical().setFromVector3(vec);
		this._phi = sph.theta;
		this._theta = sph.phi;
		//Phi and theta are exchanged in Three.js in relation to the usual notation
	}	
	/**
	 * Makes a copy of this vector.
	 * @returns {Coord.Spherical} copy of this vector.
	 */
	clone () {
		return new Coord.Spherical(this.phi, this.theta);
	}
}

/**
 * Class representing a unity vector in equatorial coordinates with RA ranging from 0 to 24hs.
 */
Coord.Equatorial = class {
    /**
     * Creates a RA 24hs equatorial representation of a unity vector.
     * @param {number} ra - the Right Ascension (0 to 24hs) coordinate.
	 * @param {number} dec - the Declination (-90ยบ to 90ยบ) coordinate.
     */
    constructor (ra = 0.0, dec = 0.0) {
		this._ra = ra;
		this._dec = dec;
		this.correctCoords();
	}
	/** Set this.ra */
	set ra (ra) {
		this._ra = ra;
		this.correctCoords();
	}
	/** Set this.dec */
	set dec (dec) {		
		this._dec = dec;
		this.correctCoords();
	}
	/** Get this.ra */
	get ra () {		
		return this._ra;
	}
	/** Get this.dec */
	get dec () {		
		return this._dec;
	}
	/**
	 * Corrects coordinates to their boundary values
	 */
	correctCoords () {
		let sph = this.toSpherical();
		this.fromSpherical(sph);
	}	
	/**
	 * Returns the rectangular representation of this object.
	 * @returns {THREE.Vector3} rectangular representation of this object.
	 */
	toVector3 () {		
		let sph = this.toSpherical();				
		return sph.toVector3();		
	}
	/**
	 * Returns the spherical representation of this object.
	 * @returns {Coord.Spherical} spherical representation of this object.
	 */
	 toSpherical () {
		let phi = this._ra*Math.PI/12;
		let theta = (90-this._dec)*Math.PI/180;				
		return new Coord.Spherical(phi, theta);		
	}
	/**
	 * Set this object from rectangular representation.	 
	 * @param {THREE.Vector3} vec - rectangular representation of a vector.
	 */
	fromVector3 (vec) {
		let sph = new Coord.Spherical();
		sph.fromVector3(vec);
		this.fromSpherical(sph);
	}
	/**
	 * Set this object from spherical representation.	 
	 * @param {Coord.Spherical} vec - spherical representation of a vector.
	 */
	fromSpherical (sph) {		
		this._ra = sph.phi*12/Math.PI;
		this._dec = (90-sph.theta*180/Math.PI);		
	}
	/**
	 * Makes a copy of this vector.
	 * @returns {Coord.Equatorial} copy of this vector.
	 */
	clone () {
		return new Coord.Equatorial(this.ra, this.dec);
	}
}

/**
 * Class representing a unity vector in step motor steps.
 */
Coord.Step = class {
    /**
     * Creates a step motor steps representation of a unity vector.
     * @param {number} fix - the fixed motor step (0 to this.maxSteps) coordinate.
	 * @param {number} mob - the mobile motor step (0 to this.maxSteps) coordinate.
     */
    constructor (fix = 0, mob = 0) {
		this._fix = fix;
		this._mob = mob;
		this.maxSteps = ESP32.STPS360;
		this.stepAtZenith = ESP32.STEP_AT_ZENITH;
		this.step90 = Math.trunc(ESP32.STPS360/4);				
		this.correctSteps();
	}
	/** Set this.fix */
	set fix (fix) {
		this._fix = fix;		
		this.correctSteps();
	}
	/** Set this.mob */
	set mob (mob) {
		this._mob = mob;
		this.correctSteps();
	}	
	/** Get this.fix */
	get fix () {		
		return this._fix;
	}
	/** Get this.mob */
	get mob () {		
		return this._mob;
	}
	/**
	 * Corrects coordinates to their boundary values.
	 */
	correctSteps () {		
		let n = Math.ceil(Math.abs(this._fix)/this.maxSteps);
		this._fix = (n*this.maxSteps + this._fix) % this.maxSteps;
		let m = Math.ceil(Math.abs(this._mob)/this.maxSteps);
		this._mob = (m*this.maxSteps + this._mob) % this.maxSteps;
	}	
	/**
	 * Returns fix coordinate in radians.
	 * @returns {number} this.fix in radians
	 */
	fixToRad () {
		return this._fix*2.0*Math.PI/this.maxSteps;
	}	
	/**
	 * Returns mob coordinate in radians.
	 * @returns {number} this.mob in radians
	 */
	mobToRad () {
		return (this._mob - this.stepAtZenith + this.step90)*2.0*Math.PI/this.maxSteps;
	}	
	/**
	 * Set fix coordinate from angle in radians
	 * @param {number} rad - angle in radians that will set the fix coordinate
	 */
	fixFromRad (rad) {
		this._fix = Math.round(rad*this.maxSteps/(2.0*Math.PI));
		this.correctSteps();
	}	
	/**
	 * Set mob coordinate from angle in radians
	 * @param {number} rad - angle in radians that will set the mob coordinate
	 */
	 mobFromRad (rad) {
		this._mob = Math.round(rad*this.maxSteps/(2.0*Math.PI)) + this.stepAtZenith - this.step90;
		this.correctSteps();
	}
	/**
	 * Make a copy of this vector.
	 * @returns {Coord.Step} copy of this vector.
	 */
	clone() {
		return new Coord.Step(this.fix, this.mob);
	}	
}

/**
 * Class representing a calibration star object.
 */
Coord.CalibStar = class {
	/**
	 * Crates a calib star object.
	 * @param {string} text - a text output with this star information	 
	 * @param {Date} date - date when the star object was measured by the StarProjector system
	 * @param {Coord.Step} step - local steppers coordinates for the star object
	 * @param {Coord.Equatorial} eq - celestial equatorial coordinates for the star object
	 */
	constructor (text = null, date = null, step = null, eq = null) {
		this.text = text;		
		this.date = date;
		this.step = step;
		this.eq = eq;
	}
}

/**
 * Class to perform the calibration of the steppers local reference frame with respect to the equatorial celestial reference frame.
 */
Coord.Calibration = class {
	/**
	 *  Cretates a calibration object.  
	 */
    constructor() {
		/**@member {Coord.CalibStar[]} - Array of star objects used to perform calibration of the reference frame. */
		this.stars = [];		
		/**@member - optimized vectors for the stepper fix, stepper mob and laser axes. */		
		this.fit = {						
			axes: {
				fix: new THREE.Vector3(1.0, 0.0, 0.0),
				mob: new THREE.Vector3(0.0, 1.0, 0.0),
				laser: new THREE.Vector3(1.0, 0.0, 0.0)
			},
			fixStretch: {value: 1.0, min: 0.8, max: 1.2, optimize: true},
			mobStretch: {value: 1.0, min: 0.8, max: 1.2, optimize: true},
			mobTilt: {value: 0.0, min: -5*Math.PI/180, max: 5*Math.PI/180, optimize: true},
			laserTilt: {value: 0.0, min: -5*Math.PI/180, max: 5*Math.PI/180, optimize: true}
		};						
		/**@member {Date} - First calib star date of assignment to calibration */
		this.t0 = new Date();
		/**@member {object} - Calibration statistics */
		this.stats = {dev: 0, min: 0, max: 0, minStar: null, maxStar: null};
		/**@member {number} - Number of tries used by the axes optmization algorithm. */
		this.axesTrial = 50;
		this.maxIter = 50;
		this.maxCalibIter = 500;
		this.maxOptimValue = (1.0 - Math.cos(1*Math.PI/1024))**0.5;
		this.maxCalibOptimumValue = (1.0 - Math.cos(1*Math.PI/1024))**0.5;
		this.sideralDay = 86164090.5; //[ms]
	}	
	/**
	 * Finds the Euler rotations that relate the local reference system to the celestial reference system.
	 * @param {Coord.CalibStar[]} stars - array of calibration stars
	 */	
    calcCalib (stars) {
		this.stars = stars;
		this.t0 = stars[0].date;
		window.equatorials = [];
		window.steps = [];
		for (let s of this.stars) {
			let eq = s.eq.clone();		
			eq.ra -= (s.date - this.t0)*24/this.sideralDay;
			window.equatorials.push(eq.toVector3());			
			window.steps.push(s.step);
		}
		window.fit = this.fit;
		window.fix = new THREE.Vector3(1.0, 0.0, 0.0);
		window.mob = new THREE.Vector3(0.0, 1.0, 0.0);
		window.laser = new THREE.Vector3(1.0, 0.0, 0.0);	
		let objFunc = function (p) {									
			let penal = 0.0;			
			let fixS = window.fit.fixStretch.value;
			let mobS = window.fit.mobStretch.value;
			window.fix = new THREE.Vector3(1.0, 0.0, 0.0);
			window.mob = new THREE.Vector3(0.0, 1.0, 0.0);
			window.laser = new THREE.Vector3(1.0, 0.0, 0.0);
			let Y = new THREE.Vector3(0.0, 1.0, 0.0);				
			let Z = new THREE.Vector3(0.0, 0.0, 1.0);				
			if (window.fit.fixStretch.optimize) {
				if (p[0] &lt; window.fit.fixStretch.min) penal += window.fit.fixStretch.min - p[0];
				if (p[0] > window.fit.fixStretch.max) penal += p[0] - window.fit.fixStretch.max;				
				fixS = p[0];				
			}
			if (window.fit.mobStretch.optimize) {
				if (p[1] &lt; window.fit.mobStretch.min) penal += window.fit.mobStretch.min - p[1];
				if (p[1] > window.fit.mobStretch.max) penal += p[1] - window.fit.mobStretch.max;
				mobS = p[1];				
			}
			if (window.fit.laserTilt.optimize) {
				if (p[2] &lt; window.fit.laserTilt.min) penal += window.fit.laserTilt.min - p[2];
				if (p[2] > window.fit.laserTilt.max) penal += p[2] - window.fit.laserTilt.max;								
				window.laser.applyAxisAngle(Z, p[2]);
			}
			window.laser.applyAxisAngle(window.mob, p[4]);
			if (window.fit.mobTilt.optimize) {
				if (p[3] &lt; window.fit.mobTilt.min) penal += window.fit.mobTilt.min - p[3];
				if (p[3] > window.fit.mobTilt.max) penal += p[3] - window.fit.mobTilt.max;								
				window.mob.applyAxisAngle(Z, p[3]);
				window.laser.applyAxisAngle(Z, p[3]);
			}
			window.mob.applyAxisAngle(window.fix, p[5]);
			window.mob.applyAxisAngle(Y, p[6]);
			window.mob.applyAxisAngle(Z, p[7]);
			window.laser.applyAxisAngle(window.fix, p[5]);
			window.laser.applyAxisAngle(Y, p[6]);
			window.laser.applyAxisAngle(Z, p[7]);
			window.fix.applyAxisAngle(Y, p[6]);
			window.fix.applyAxisAngle(Z, p[7]);
			
			let N = window.steps.length;
			let dots = 0;
			for (let i = 0; i &lt; N; i++) {
				let l = window.laser.clone();				
				l.applyAxisAngle(window.mob, window.steps[i].mobToRad()*mobS);
				l.applyAxisAngle(window.fix, window.steps[i].fixToRad()*fixS);				
				dots += l.dot(window.equatorials[i]);
			}
			return (1 - dots/N)**0.5 + penal;
		}
		let p0;				
		let P;
		let bestValue = 1000;
		let i = 0;
		do {			
			p0 = [
				this.fit.fixStretch.min + Math.random()*(this.fit.fixStretch.max - this.fit.fixStretch.min),
				this.fit.mobStretch.min + Math.random()*(this.fit.mobStretch.max - this.fit.mobStretch.min),
				this.fit.laserTilt.min + Math.random()*(this.fit.laserTilt.max - this.fit.laserTilt.min),
				this.fit.mobTilt.min + Math.random()*(this.fit.mobTilt.max - this.fit.mobTilt.min),				
				Math.random()*2*Math.PI,
				Math.random()*2*Math.PI,
				Math.random()*Math.PI,
				Math.random()*2*Math.PI
			];						
			let res = nelderMead(objFunc, p0);		
			if (res.fx &lt; bestValue) {
				bestValue = res.fx;
				P = res.x;
			}		
		} while ((i++ &lt; this.maxCalibIter) &amp;&amp; (bestValue > this.maxCalibOptimumValue));
		if (i >= this.maxCalibIter) alert('Calibration could not converge to maxCalibOptimValue!');				
				
		this.fit.fixStretch.value = P[0];
		this.fit.mobStretch.value = P[1];
		this.fit.laserTilt.value = P[2];
		this.fit.mobTilt.value = P[3];
		objFunc(P); // actualizes window.fix, window.mob and window.laser with optimized parameters P		
		this.fit.axes.fix = window.fix.clone();
		this.fit.axes.mob = window.mob.clone();
		this.fit.axes.laser = window.laser.clone();				

		this.stats.dev = 0;
		this.stats.min = 1e3;
		this.stats.max = 0;
		let eq1, eq2, ang;
		for (let s of this.stars) {
			eq1 = this.equatorialFromStep(s.step, s.date).toVector3();				
			eq2 = s.eq.toVector3();
			ang = eq1.angleTo(eq2)*180/Math.PI;
			if (ang &lt; this.stats.min) {
				this.stats.min = ang;
				this.stats.minStar = s.text;
			}
			if (ang > this.stats.max) {
				this.stats.max = ang;
				this.stats.maxStar = s.text;
			}
			this.stats.dev += ang/this.stars.length;
		}
	}
	/**
	 * Celestial from Local coordinates convertion on the given date.	 
	 * @param {Coord.Step} s - local coordinate
	 * @param {Date} d - given date (actual date, if ommitted)
	 * @returns {Coord.Equatorial} celestial coordinate
	 */
	equatorialFromStep (s, d = new Date()) {		
		let laser = this.fit.axes.laser.clone();		
		laser.applyAxisAngle(this.fit.axes.mob, s.mobToRad()*this.fit.mobStretch.value);
		laser.applyAxisAngle(this.fit.axes.fix, s.fixToRad()*this.fit.fixStretch.value);		
		let eq = new Coord.Equatorial();
		eq.fromVector3(laser);		
		eq.ra += (d - this.t0)/3.6e6;
		return eq;
	}	
	/**
	 * Local from Celestial coordinates convertion on the given date.
	 * @param {Coord.Equatorial} eq - celestial coordinate
	 * @param {Date} d - given date (actual date, if ommitted)
	 * @returns {Coord.Step} local coordinate
	 */
	stepFromEquatorial (eq0, d = new Date()) {
		let eq = eq0.clone();		
		eq.ra -= (d - this.t0)/3.6e6;
		window.eq3 = eq.toVector3();
		window.fix = this.fit.axes.fix;
		window.mob = this.fit.axes.mob;
		window.laser = this.fit.axes.laser;
		window.fixStretch = this.fit.fixStretch.value;
		window.mobStretch = this.fit.mobStretch.value;					
		let optimFunction = function (s) {
			let laser = window.laser.clone();					
			let penal = 0.0;
			if (s[0] > 2*Math.PI) penal += s[0] - 2*Math.PI;
			if (s[0] &lt; 0.0) penal += -s[0];
			if (s[1] > Math.PI) penal += s[1] - Math.PI;
			if (s[1] &lt; 0.0) penal += -s[1];
			laser.applyAxisAngle(window.mob, s[1]*window.mobStretch);
			laser.applyAxisAngle(window.fix, s[0]*window.fixStretch);			
			return (1.0 - laser.dot(window.eq3))**0.5 + penal;			
		}
		let optAngs;
		let bestValue = 1.0;
		let i = 0;
		do {
			let res = nelderMead(optimFunction, [Math.random()*2*Math.PI, Math.random()*Math.PI]);		
			if (res.fx &lt; bestValue) {
				bestValue = res.fx;
				optAngs = res.x;
			}
		} while ((i++ &lt; this.maxIter) &amp;&amp; (bestValue > this.maxOptimValue));		
		if (i >= this.maxIter) alert('stepFromEquatorial could not converge. Do not execute path!');		
		let step = new Coord.Step();		
		step.fixFromRad(optAngs[0]);
		step.mobFromRad(optAngs[1]);
		return step;
	}
	/**
	 * Makes a copy of this object.
	 * @returns {Coord.Calib} copy of this object.
	 */
	clone () {
		let Calib = new Coord.Calibration();
		Calib.stars = this.stars;		
		for (let x in this.fit) Calib.fit[x] = this.fit[x];				
		Calib.t0 = this.t0;		
		for (let x in this.stats) Calib.stats[x] = this.stats[x];
		Calib.axesTrial = this.axesTrial;
		return Calib;
	}
}

/**
 * A namespace for the Communication operations between the StarPointer WebApp client and the ESP32 server.
 * @namespace
 */
let Comm = {};

/**
 * Class for the parsed path construction.
 */
Comm.CommPath = class {
	/**
	 * Creates a parsed path to send to the ESP32 server.
	 * @param {Path.Path} Path - Path to be parsed.
	 * @param {Coord.Calibration} Calib - calibration used to transform celestial to step coordinates
	*/
	constructor (Path, Calib) {
		/**@member {number[]} - Number of bits of the base used to represent the path segments, respectively for: laser state, step delay, fix step, mob step. */
		this._encBase = ESP32.PATHBASE;
		/**@member {number[]} - Number of bits of the base used to communicate the path segments. */
		this._decBase = ESP32.COMMBASE;
		/**@member {Path.Path} */
		this._path = Path;
		/**@member {Coord.Calibration} */
		this.calib = Calib;
		/**@member {number[]} - Parsed path obtained from this._path. */
		this._parsedPath = [];
		/**@member {boolean} - True if path clipped due to be below horizon. */
		this.clipped = false;
		this.composePath();
	}
	/**
	 * Checks if the laser will point above the horizon for safe operation.
	 * @method
	 * @param {Coord.Step} Step - step to be checked if is above horizon. 
	 * @returns {boolean} true if above horizon, false otherwise.
	 */
	isAboveHorizon (Step) {
		let ph = (Step.fix-ESP32.STPS360/4.0)*2*Math.PI/ESP32.STPS360;
		let th = (Step.mob-ESP32.STPS360/4.0)*2*Math.PI/ESP32.STPS360;		
		let x = Math.cos(ph)*Math.sin(th);
		let y = Math.sin(ph)*Math.sin(th);
		let z = Math.cos(th);
		let tanH = y/sqrt(x*x+z*z);		
  		if (tanH > Math.tan(ESP32.HORIZON_MIN_ANG*Math.PI/180)) return true;
		else return false;		
	}

	/**
	 * Parses a segment to be added to a parsed path.
	 * @param {Path.Segment} Segment - Segment to be parsed. 	 
	 * @returns {number[]} Array with decBase size representing the parsed segment.
	 */
	parseSegment (Segment) {		
		//Encoding to this._encBase:		
		let step = Segment.coord;
		if (Segment.coord instanceof Coord.Equatorial) step = this.calib.stepFromEquatorial(Segment.coord);						
		let data = [Segment.laser, Segment.delay, step.fix, step.mob];
		let x0 = 0;
		let b = 0;
		for (let i = 0; i &lt; this._encBase.length; i++) {
			x0 += data[i]*2**b;
			b += this._encBase[i];
		}
		//Decoding to this._decBase:
		let b0 = 0;
		let r0 = x0;
		let r = [];
		for (let i = 0; i &lt; this._decBase.length; i++) {
			r.push( Math.trunc(r0 / 2**b0) % 2**this._decBase[i] );
			b0 += this._decBase[i];
			r0 -= r[i];
		}
		return r;
	}
	/**
	 * Method for parsing this._path.
	 */
	composePath () {
		this.clipped = false;
		this._parsedPath = [];				
		let path = this._path.path;		
		for (let i = 0; i &lt; path.length; i++) {
			if (path[i].coord instanceof Coord.Equatorial) path[i].coord = this.calib.stepFromEquatorial(path[i].coord);							
			if (this.isAboveHorizon(path[i].coord)) {
				//console.log(path[i].laser);
				let seg = new Path.Segment(path[i].coord, path[i].laser, path[i].delay);
				//if (i+1 &lt; path.length)
				if (i-1 >= 0)
					if (!this.isAboveHorizon(path[i-1].coord)) {
						seg.laser = 0;
						seg.delay = 0;
						this.clipped = true;
					}
				//console.log(path[i].laser);
				//console.log('-------------');
				this._parsedPath = this._parsedPath.concat(this.parseSegment(seg));												
			}
		}
	}
	/**Set path. */
	set path (Path) {
		this._path = Path;
		this.composePath();
	}
	/**Set encBase. */
	set encBase (encBase) {
		this._encBase = encBase;
		this.composePath();
	}
	/**Set decBase. */
	set decBase (decBase) {
		this._decBase = decBase;
		this.composePath();
	}
	/**Get path. */
	get path () {
		return this._path;
	}
	/**Get encBase. */
	get encBase () {
		return this._encBase;
	}
	/**Get decBase. */
	get decBase () {
		return this._decBase;
	}
	/**Get parsedPath. */
	get parsedPath () {
		this.composePath();
		return this._parsedPath;
	}
	/**Get this path size */
	get size () {
		return this._path.size;
	}
}

/**
 * Class to communicate via Low Energy Bluetooth with the Star Pointer ESP32 server.
 * @param {Object} - DOM element whose innerHTML attribute receives the communication logs.
 * @param {Object} - DOM element to indicate when in the unsafe mode.
*/
Comm.Bluetooth = class {
	/**
	 * Creates a bluetooth connection.
	 * @param {*} logDOM - DOM element whose innerHTML attribute receives the communication logs. 
	 * @param {*} unsafeDOM - DOM element to indicate when in the unsafe mode. 
	 */
	constructor (logDOM, unsafeDOM) {
		/**@member {string} - Server device name.*/
		this.deviceName = ESP32.DEVICE_NAME;
		/**@member {string} - The single service for all device's characteristics.*/
		this.mainS_UUID = ESP32.MAIN_S_UUID;
		/**@member {string} - Characteristic UUID for the Comm.parsedPath transmission.*/
		this.pathC_UUID = ESP32.PATH_C_UUID;
		/**@member {string} - Characteristic UUID for sending commands to server.*/
		this.commandC_UUID = ESP32.COMMAND_C_UUID;
		/**@member {string} - Characteristic UUID for measuring the steppers position.*/
		this.steppersC_UUID = ESP32.STEPPERS_C_UUID;
		/**@member {string} - Characteristic UUID for measuring ESP32 status.*/
		this.statusC_UUID = ESP32.STATUS_C_UUID;		
		/**@member {Object} - DOM element whose innerHTML attribute receives the communication logs.*/
		this.logDOM = logDOM;
		/**@member {Object} - DOM element to indicate unsafe mode operation.*/
		this.unsafeDOM = unsafeDOM;
		/**@member {number} - 1 byte array maximum size to be sent to the server. */
		this.maxChunk = 512;
		/**@member {Object} - Execution options to ESP32 server. */
		this.OPT = ESP32;
		/**@member {Coord.Step} - the steppers fix and mob coordinates obtained from the accelerometer readings. */
		this.actStep = new Coord.Step(0, 0);
		this.serverStatus = {
			idle: false,
			laserOn: false,
			unsafeMode: false,
			safeHeight: false,
			leveled: false,
			tilted: false
		};		
	}
	/**
	 * Returns actual time in the format: hours minutes seconds.
	 */
	time () {
		let d = new Date();
		return d.getHours() + 'h' + d.getMinutes() + 'm' + d.getSeconds() + 's: ';
	}	
	/**
	 * Starts bluetooth communication with ESP32 server.
	 * @returns {boolean} connection status.
	 */
	async startComm () {
		let deviceOptions = {
			filters: [{ name: this.deviceName }],
			optionalServices: [
				this.mainS_UUID, 
				this.pathC_UUID,
				this.commandC_UUID,    
				this.steppersC_UUID,
				this.statusC_UUID]};
		try {
			this.logDOM.innerHTML = this.time() + 'Requesting StarPointer Device...\n';      
			this.device = await navigator.bluetooth.requestDevice(deviceOptions);
			
			this.logDOM.innerHTML += this.time() + 'Connecting to GATT Server...\n';
			this.server = await this.device.gatt.connect();
			
			this.logDOM.innerHTML += this.time() + 'Getting GAP Services...\n';
			this.mainS = await this.server.getPrimaryService(this.mainS_UUID);
			
			this.logDOM.innerHTML += this.time() + 'Getting GAP Characteristics...\n';
			this.pathC = await this.mainS.getCharacteristic(this.pathC_UUID);
			this.commandC = await this.mainS.getCharacteristic(this.commandC_UUID);
			this.steppersC = await this.mainS.getCharacteristic(this.steppersC_UUID);
			this.statusC = await this.mainS.getCharacteristic(this.statusC_UUID);
			this.logDOM.innerHTML += this.time() + 'Connected to StarPointer on ESP32 Server.\n';

			this.getStatus();
			return true;    
		}
		catch(error) {
			this.logDOM.innerHTML += error + '\n';
			return false;
		}	
	}
	/**
	 * Sends an Alert informing disconnection with server.
	 * @param {string} errorMsg - to be displayed with the disconnected message.
	 * @returns false
	 */
	disconnectMsg (errorMsg) {
		this.logDOM.innerHTML += this.time() + errorMsg + '. StarPointer disconnected!\n';
		alert(errorMsg + '. StarPointer disconnected! Start comm again.');
		return false;
	}
    
	/**
	 * Sends a this.Opt item to ESP32 Server.
	 * @param {number} optValue - A valid this.Opt item value.
	 */
	async sendCommand (optValue) {
		let optKey = false;
		for (let x of Object.entries(this.OPT)) if (x[1] == optValue) optKey = x[0];		
		if (optKey) {			
			this.logDOM.innerHTML += this.time() + 'Option ' + optKey + ' sent to Server.\n';
			await this.commandC.writeValue(new Uint8Array([optValue]));						
			return true;
		}
		else {
		  this.logDOM.innerHTML += this.time() + 'Option ' + option + ' not recognized. Nothing sent to Server.\n';
		  return false;
		}
	}
	/**
	 * Executes a step size on steppers in the ESP32 server.
	 * @param {number} stepSize - Step size between 1 and 128.
	 * @param {string} dirs - String in the format 'xab', where x is any alphabetic character, a and b control the fixed and mobile steppers, respectively, and each one can assume the characters: '0' = move backward, '1' = stay still, and '2' = move forward.
	 */
	async goStepSize (stepSize, dirs) {
		try {
			if (await this.getStatus()) {			
				let fix = Math.max((parseInt(dirs[1])-1)*stepSize + 127, 0);
				let mob = Math.max((parseInt(dirs[2])-1)*stepSize + 127, 0);
				await this.commandC.writeValue(new Uint8Array([fix, mob]));
				this.logDOM.innerHTML += this.time() + 'Step size of (' + (fix-127) + ',' + (mob-127) + ') sent to (fixed,mobile) steppers on Server.\n';
				return true;
			}
			else return false;
		} catch {return this.disconnectMsg();}
	}	
	/**
	 * Executes a parsedPath on steppers in the ESP32 server.
	 * @param {Comm.CommPath} Path - Path to be executed by the ESP32 server steppers.
	 * @param {string} cyclicOpt - 'single': path is executed once; 'forward': path is excuted cyclically forward until stop signal; 'alternate': path is excuted cyclically alternate until stop signal.
	 */
	async goPath (Path, cyclicOpt = 'single') {  		
	    try {
			if (await this.getStatus()) {			
				let path = Path.parsedPath;			
				if (path.length == 0) {
					alert ('Path execution ignored due to steppers elevation out of bounds.');
					return false;
				}
				else {
					if (Path.clipped) alert('Path clipped due to steppers elevation out of bounds.');
					await this.sendCommand(this.OPT.RESET_PATH_OPT);
					let j = 0;
					let pathChunk;
					for (let i = 0; i &lt; path.length; i++) {
							j = i % this.maxChunk;
						if (j == 0) {      
							if (path.length - i >= this.maxChunk) pathChunk = new Uint8Array(this.maxChunk);
							else pathChunk = new Uint8Array(path.length - i);
						}
						pathChunk[j] = path[i];
						if ((j == this.maxChunk - 1) || (i == path.length -1)) {
							await this.pathC.writeValue(pathChunk);
						}
					}
					this.logDOM.innerHTML += this.time() + 'Path with ' + Path.size + ' segments sent to Server.\n';
					switch (cyclicOpt) {
						case 'single':
							await this.sendCommand(this.OPT.EXEC_PATH_OPT);
							break;
						case 'forward':
							await this.sendCommand(this.OPT.CYCLIC_PATH_OPT);
							break;
						case 'alternate':
							await this.sendCommand(this.OPT.REVERSE_PATH_OPT);
							break;
					}				
					this.logDOM.innerHTML += this.time() + 'Path execution with Cyclic Option = ' + cyclicOpt + '.\n';
					return true;
				}
			} else return false;
		} catch (error) {return this.disconnectMsg(error);}
	}
	/**
	 * Switchs the laser status on/off in the ESP32 server.
	 */
	async goLaser () {
		try {			
			if (await this.getStatus()) {				
				await this.sendCommand(this.OPT.LASER_SWITCH_OPT);
				return true;
			} else return false;															
		} catch (error) {			
			return this.disconnectMsg(error);}		
	}
	/**
	 * Set actual steppers step values to ESP32.STEP_AT_ZENITH.	 
	 */
	async setZenith() {
		try {			
			if (await this.getStatus()) {
				await this.sendCommand(this.OPT.SET_ZENITH_OPT);																				
				return true;
			} else return false;
		} catch (error) {			
			return this.disconnectMsg(error);
		}
	}
	/**
	 * Read the steppers fix and mob coordinates in the ESP32 server.
	 */
	async readActSteps () {		
	    try {			
			let value = await this.steppersC.readValue();							
			let fix = value.getUint8(0)*256 + value.getUint8(1);
			let mob = value.getUint8(2)*256 + value.getUint8(3);
			this.logDOM.innerHTML += this.time() + 'Actual steps readings from server: fix=' + fix + ', mob=' + mob + '\n';
			this.actStep = new Coord.Step(fix, mob);										
			return true;						
		} catch (error) {return this.disconnectMsg(error);}
	}
	/**
	 * Check status from server and emits alert message for safe and correct use.
	 * @returns true if it receives status from ESP32 sever, false otherwise.
	 */
	async getStatus () {
		try {
			let status = await this.statusC.readValue();		
			this.serverStatus.idle = status.getUint8(0);			
			this.serverStatus.laserOn = status.getUint8(1);
			let unsafeMode = status.getUint8(2);
			let safeHeight = status.getUint8(3);
			let leveled = status.getUint8(4);
			let tilted = status.getUint8(5);

			if (unsafeMode) this.unsafeDOM.style.display = "block";
			else this.unsafeDOM.style.display = "none";

			if ((unsafeMode != this.serverStatus.unsafeMode) &amp;&amp; unsafeMode) alert ('Atention! Horus operating in unsafe mode. Use it with caution.');	
			if (!unsafeMode) {
				let msg = '';
				if (!safeHeight) msg += 'Distance to the ground is unsafe. ';
				if (!leveled) msg += 'Horus is not leveled. ';
				if (msg != '') alert('Atention! ' + msg + 'Set up the equipament correctly. No commands executed.');
			}
			if (tilted) alert ('Atention! Horus changed orientation. Calibration may have been impaired.');

			this.serverStatus.unsafeMode = unsafeMode;
			this.serverStatus.safeHeight = safeHeight;
			this.serverStatus.leveled = leveled;
			this.serverStatus.tilted = tilted;
			
			if ((safeHeight &amp;&amp; leveled) || unsafeMode) return true;
			else return false;

		} catch {
			return false;
		}
	}		
}


/**
 * A namespace for the Path operations in the StarPointer app'.
 * @namespace
 */
let Path = {};

/**
 * Class for the Star Pointer Segment construction.
 */
Path.Segment = class {
    /**
     * Creates a segment for the path followed by the Star Pointer composed by equatorial or steps coords, laser status and time delay between steps.
	 * @param {Coord.Equatorial|Coord.Step} coord - equatorial or step coords of the path segment.
	 * @param {number} laser - Laser state: 0 = off, 1 = on.
	 * @param {number} delay - Time delay between steppers sucessive steps in multiples of 100 us.
     */
	constructor (coord, laser, delay) {
		this.coord = coord;
		this.laser = laser;
		this.delay = delay;
	}
}

/**
 * Class for the Star Pointer General Path construction.
 */
Path.Path = class {
    /**
	 * Creates the path followed by the Star Pointer composed by equatorial or step coords, laser status and time delay between steps.
	 */
	constructor () {
		this.reset();
	}
	/**
	 * Resets Path.Path variables.
	 */
    reset () {		
		/**@member {Path.Segment[]} - array of Segment objects. */
		this.path = [];
		/**@member {number} - Path.path number of segments. */
		this.size = 0;
		/**@member {number} - Sum of all Path.path segments delay in 100 us unit. */
		this.duration = 0;
	}
	/**
	 * Add segment object to the path.
	 * @param {Path.Segment} Segment
	 */
	addSegment (Segment) {
		this.path.push(Segment);
		this.size = this.path.length;
		this.duration += Segment.delay;
	}
	/** 
	 * Concatenate path.
	 * @param {Path.Path} Path
	 */
	addPath (Path) {
		this.path = this.path.concat(Path.path);
		this.size += Path.size;
		this.duration += Path.duration;
	}
}

/** 
* Function to generate a circular path trajectory.
* @param {Coord.Equatorial} Center - celestial coordinate of circle center.
* @param {number|Coord.Equatorial} border - circle angle aperture in rad or celestial coordinate of a point at the circle border.
* @param {number} angleIncrement - angle step for the circle discretization in rad.
* @param {Array} lpattern - [laser on number of steps, laser off number of steps].
* @param {number} delay - time delay between steppers sucessive steps in multiples of 100 us.
* @returns {Path.Path} path for the circular trajectory.
*/
Path.makeCircle = function (Center, border, angleIncrement, lpattern, delay) {
	let path = new Path.Path();
	let c = Center.toVector3();
	let b;
	if (typeof(border.phi) == 'undefined') {
		b = new Coord.Equatorial(Center.ra, Center.dec+border*180/Math.PI);		
	}
	else {
		b = border;
	}
	let v0 = b.toVector3();
	let N = Math.round(2*Math.PI/angleIncrement);		
	let r = lpattern[0] + lpattern[1];	
	let laser;	
	for (let i = 0; i &lt; N; i++) {
		let v = v0.clone();
		v.applyAxisAngle(c, i*angleIncrement);
		laser = 0;
		if ((i%r) &lt; lpattern[0]) laser = 1;
		let eq = new Coord.Equatorial();
		eq.fromVector3(v);
		let segment = new Path.Segment(eq, laser, delay);
		path.addSegment(segment);
	}
	return path;   
}

/**
* Function to generate a geodesic path trajectory.
* @param {Coord.Equatorial} eq0 - geodesic starting point.
* @param {Coord.Equatorial} eq1 - geodesic ending point.
* @param {number} angleIncrement - angle step for the geodesic discretization in rad.
* @param {Array} lpattern - [laser on number of steps, laser off number of steps].
* @param {number} delay - time delay between steppers sucessive steps in multiples of 100 us.
* @returns {Path.Path} path for the geodesic trajectory.
*/
Path.makeGeodesic = function (eq0, eq1, angleIncrement, lpattern, delay) {
	let path = new Path.Path();
	let v0 = eq0.toVector3();
	let v1 = eq1.toVector3();
	let a = v0.angleTo(v1);
	let N = Math.max(1.0, Math.round(Math.abs(a/angleIncrement)));
	let ainc = a/N;
	let v3 = new THREE.Vector3();
	v3.crossVectors(v0, v1).normalize();
	let r = lpattern[0] + lpattern[1];
	let laser;	
	for (let i = 0; i &lt;= N; i++) {
		let v = v0.clone();
		v.applyAxisAngle(v3, i*ainc);
		laser = 0;
		if ((i%r) &lt; lpattern[0]) laser = 1;
		let eq = new Coord.Equatorial();
		eq.fromVector3(v);
		let segment = new Path.Segment(eq, laser, delay);
		path.addSegment(segment);
	}
	return path;   
}

export {ESP32, Coord, Comm, Path};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="hathor.module_module.html">module</a></li></ul><h3>Namespaces</h3><ul><li><a href="hathor.module_module-Comm.html">Comm</a></li><li><a href="hathor.module_module-Coord.html">Coord</a></li><li><a href="hathor.module_module-Path.html">Path</a></li></ul><h3>Classes</h3><ul><li><a href="hathor.module_module-Comm.Bluetooth.html">Bluetooth</a></li><li><a href="hathor.module_module-Comm.CommPath.html">CommPath</a></li><li><a href="hathor.module_module-Coord.Calibration.html">Calibration</a></li><li><a href="hathor.module_module-Coord.CalibStar.html">CalibStar</a></li><li><a href="hathor.module_module-Coord.Equatorial.html">Equatorial</a></li><li><a href="hathor.module_module-Coord.Spherical.html">Spherical</a></li><li><a href="hathor.module_module-Coord.Step.html">Step</a></li><li><a href="hathor.module_module-Path.Path.html">Path</a></li><li><a href="hathor.module_module-Path.Segment.html">Segment</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Mon Oct 04 2021 20:22:49 GMT-0300 (Brasilia Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
